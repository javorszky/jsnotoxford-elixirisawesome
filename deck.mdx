import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { oceanicNext } from "@code-surfer/themes";
import {
  themes,
} from "mdx-deck"
import "prismjs/components/prism-elixir"
import "prismjs/components/prism-go"

import elixirlogo from "./static/elixirlogo.png"
export const theme = themes.yellow;


# Elixir is amazing! üòç

---

# Who?

## Gabor Javorszky
backend developer (Go mainly)

Hello üëã

---

# But what is

<img src={elixirlogo} />

---
<blockquote>
  <p>‚ÄùElixir is a dynamic, functional language designed for building scalable and maintainable applications.</p>
  <p>Elixir leverages the Erlang VM, known for running low-latency, distributed and fault-tolerant systems, while also being successfully used in web development, embedded software, data ingestion, and multimedia processing domains across a wide range of industries.‚Äù</p>
  <footer>
    <cite>‚Äî <a href="https://elixir-lang.org/">elixir site</a></cite>
  </footer>
</blockquote>

---

### dynamic:

no type hint / type coercion when writing code

### functional:

everything is done with functions with no side effects. Also data is immutable!

---

# note before we go further

I'm on page 100 of the 350 page book.

I don't know a LOT of things.

But these have blown my mind so far!

---

# 1

<div style="padding: 20px"><p>
pretty much most things are an expression. An expression is a thing that has a return value.</p></div>


<CodeSurferColumns themes={[oceanicNext,themes.yellow]}  sizes={[3,2]}>

<Step>

```elixir
iex(1) > 2 * (
          3+ 1
        )/ 4
2.0
```

Everything together

</Step>

<Step>

```elixir 1[1:8]
iex(1) > 2 * (
          3+ 1
        )/ 4
2.0
```

The shell

</Step>

<Step>

```elixir 1[10:14],2,3
iex(1) > 2 * (
          3+ 1
        )/ 4
2.0
```

<div style="padding: 20px">
<p>An expression</p><p>If you hit enter in the shell while the expression is not finished, it will give you a new line to keep writing. Once the expression can be finished, it evaluates.</p>
</div>


</Step>

<Step>

```elixir 4
iex(1) > 2 * (
          3+ 1
        )/ 4
2.0
```

the return value

</Step>

</CodeSurferColumns>

---

# 2

<div style="padding: 20px"><p>
Code is organised into modules and functions within those modules</p></div>

<CodeSurferColumns themes={[oceanicNext,themes.yellow]}  sizes={[3,2]}>

<Step>

```elixir
defmodule MyModule
  def add(x, y) do
    x+y
  end
end
```

<div style="padding: 20px">
<p>A module with a function</p>
</div>

</Step>

<Step>

```elixir 1,5
defmodule MyModule
  def add(x, y) do
    x+y
  end
end
```

<div style="padding: 20px">
<p>Module definition goes between `defmodule SomeName do ... end` blocks</p>
</div>

</Step>

<Step>

```elixir 2:4
defmodule MyModule
  def add(x, y) do
    x+y
  end
end
```

<div style="padding: 20px">
<p>Function definition goes between `def SomeName do ... end` blocks</p>
</div>

</Step>

</CodeSurferColumns>

---

# 3

<div style="padding: 20px">
<p>Functions with the same name, but different <i>arity</i> are different functions.</p>

<p>Arity: how many arguments go into a function.</p>
</div>

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir 1:17
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    0.25 * 1.7320508075688772 * x * x
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    0.5 * base * base * :math.sqrt(((sides*sides)/(base*base)) - 0.25)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>Triangle module with three different functions all called `area` to calculate the areas differently for each of them.</p>
</div>

</Step>

<Step>

```elixir 2:5
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    0.25 * 1.7320508075688772 * x * x
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    0.5 * base * base * :math.sqrt(((sides*sides)/(base*base)) - 0.25)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>This is denoted as `Triangle.area/1`</p><p>The `/n` shows how many arguments go into a function</p>
</div>

</Step>

<Step>

```elixir 7:10
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    0.25 * 1.7320508075688772 * x * x
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    0.5 * base * base * :math.sqrt(((sides*sides)/(base*base)) - 0.25)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>Triangle.area/2</p>
</div>

</Step>

<Step>

```elixir 11:16
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    0.25 * 1.7320508075688772 * x * x
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    0.5 * base * base * :math.sqrt(((sides*sides)/(base*base)) - 0.25)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>Triangle.area/3</p>
</div>

</Step>

</CodeSurferColumns>

---

# 4

## Private functions!

Functions that can only be called by the same module.

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir 1:17
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    0.25 * 1.7320508075688772 * x * x
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    0.5 * base * base * :math.sqrt(((sides*sides)/(base*base)) - 0.25)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>This can be done more generically</p>
</div>

</Step>

<Step>

```elixir 4,9,14,17:20
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    generic_area(x, x, x)
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    generic_area(base, sides, sides)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    generic_area(x, y, z)
  end

  defp generic_area(x, y, z) do
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>`defp` is a private function. Only functions inside the same module can call it. You can't call Triangle.generic_area.</p>
</div>

</Step>

<Step>

```elixir
iex(2)> Triangle.area(3)
calculating equilateral triangle
3.897114317029974
iex(3)> Triangle.area(3,3)
calculating isosceles triangle
3.897114317029974
iex(4)> Triangle.area(3,3,3)
calculating scalene triangle
3.897114317029974
iex(5)> Triangle.generic_area(3,3,3)
** (UndefinedFunctionError) function Triangle.generic_area/3 is undefined or private
    Triangle.generic_area(3, 3, 3)
```

<div style="padding: 20px">
<p>Output confirms that it works :)</p><p>And that you also can't call the private function</p>
</div>

</Step>

</CodeSurferColumns>

---

# 5

## A list is a singly linked list

An thus has an O(n) complexity to traverse or do pretty much anything with them.

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
[1, 2, 3, 4]

is the same as

[1 | [2, 3, 4]]

and

[1 | [2 | [3, 4]]]

and

[1 | [2 | [3 | [4]]]
```

```elixir
[head | tail]

where tail is the "rest of the list", or the rest of the ü¶â
```

</Step>

<Step>

```elixir 5[2]
[1, 2, 3, 4]

is the same as

[1 | [2, 3, 4]]

and

[1 | [2 | [3, 4]]]

and

[1 | [2 | [3 | [4]]]
```

```elixir
[head | tail]

where tail is the "rest of the list", or the rest of the ü¶â
```

</Step>

<Step>

```elixir 5[6:14]
[1, 2, 3, 4]

is the same as

[1 | [2, 3, 4]]

and

[1 | [2 | [3, 4]]]

and

[1 | [2 | [3 | [4]]]
```

```elixir
[head | tail]

where tail is the "rest of the list", or the rest of the ü¶â
```

</Step>

</CodeSurferColumns>

---

# 6

## the = is actually pattern matching

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
iex(1) > person = {"Bob", 25}
```

<div style="padding: 20px">
<p>the thing on the right is matched into the thing on the left. `person` is going to be bound to that tuple</p>
</div>

</Step>

<Step>

```elixir
iex(1)> {name, age} = {"Bob", 25}
{"Bob", 25}
iex(2)> name
"Bob"
iex(3)> age
25
```

<div style="padding: 20px">
<p>super useful to extract things from other things</p>
</div>

</Step>

<Step>

```elixir 1[10:13,24:28]
iex(1)> {name, age} = {"Bob", 25}
{"Bob", 25}
iex(2)> name
"Bob"
iex(3)> age
25
```

<div style="padding: 20px">
<p>super useful to extract things from other things</p>
</div>

</Step>

<Step>

```elixir 1[15:18,31:32]
iex(1)> {name, age} = {"Bob", 25}
{"Bob", 25}
iex(2)> name
"Bob"
iex(3)> age
25
```

<div style="padding: 20px">
<p>super useful to extract things from other things</p>
</div>

</Step>

</CodeSurferColumns>

---

Which also means we can do super cool extraction stuff like getting only the hour of the local time!

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
iex(5)> :calendar.local_time()
{{2021, 1, 13}, {17, 4, 16}}
```

<div style="padding: 20px">
<p>nonmatched but evaluated local time looks like this</p>
</div>

</Step>

<Step>

```elixir
iex(6)> {_, time} = :calendar.local_time()
{{2021, 1, 13}, {17, 4, 16}}
iex(7)> time
{17, 4, 16}
```

<div style="padding: 20px">
<p>separate them to date and time. The underscore means we don't care about that. Match it, but don't bind it.</p>
</div>

</Step>

<Step>

```elixir
iex(8)> {_, {hour, _, _}} = :calendar.local_time()
{{2021, 1, 13}, {17, 4, 16}}
iex(9)> hour
17
```

<div style="padding: 20px">
<p>and voila, we can go arbitrarily deep in the structure of the result.</p>
</div>

</Step>

</CodeSurferColumns>

---

Because the = is a match, we can do things like this:

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
iex(12)> {amount, amount, amount} = {127, 127, 127}
{127, 127, 127}
```

<div style="padding: 20px">
<p>this matches, because all elements on the right are the same</p>
</div>

</Step>

<Step>

```elixir
iex(13)> {amount, amount, amount} = {127, 127, 1}
** (MatchError) no match of right hand side value: {127, 127, 1}
```

<div style="padding: 20px">
<p>this does not match, because the left pattern wants three equal things, the right doesn't have it</p>
</div>

</Step>

<Step>

```elixir
iex(14)> expected_name = "Bob"
"Bob"
iex(15)> {^expected_name, _} = {"Bob", 25}
{"Bob", 25}
iex(16)> {^expected_name, _} = {"Alice", 30}
** (MatchError) no match of right hand side value: {"Alice", 30}
```

<div style="padding: 20px">
<p>Matches to the content of the variable expected_name. Unless Alice is not Bob.</p>
</div>

</Step>

</CodeSurferColumns>

---

Remember how lists are linked lists with head / tail?

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
iex(3)> [head | tail] = [1, 2, 3]
[1, 2, 3]
iex(4)> head
1
iex(5)> tail
[2, 3]
```

<div style="padding: 20px">
<p>easy to separate them</p>
</div>

</Step>

<Step>

```elixir 1[10:13,26],3,4
iex(3)> [head | tail] = [1, 2, 3]
[1, 2, 3]
iex(4)> head
1
iex(5)> tail
[2, 3]
```

<div style="padding: 20px">
<p>easy to separate them</p>
</div>

</Step>

<Step>

```elixir 1[17:20,29:32],5,6
iex(3)> [head | tail] = [1, 2, 3]
[1, 2, 3]
iex(4)> head
1
iex(5)> tail
[2, 3]
```

<div style="padding: 20px">
<p>easy to separate them</p>
</div>

</Step>

<Step>

```elixir 1:8
iex(1)> [first, second, third] = [1, 2, 3]
[1, 2, 3]
iex(2)> first
1
iex(3)> second
2
iex(4)> third
3
```

<div style="padding: 20px">
<p>or if you'd like to deconstruct the entire list, do that</p>
</div>

</Step>

</CodeSurferColumns>

---

# 7

## multiclause functions

<div style="padding: 20px">
<p>Functions with different arity are different, right? But if you combine same arity and pattern matching, magic happens!</p>
</div>

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
defmodule Geometry do
  def area({:rectangle, a, b}) do
    a * b
  end
  def area({:square, a}) do
    a * a
  end
  def area({:circle, r}) do
    r * r * 3.14
  end
end
```

<div style="padding: 20px">
<p>all three are `area/1`, because the one argument they take is a tuple between the curly braces</p><p>the difference is what's in the tuple</p>
</div>

</Step>

<Step>

```elixir 1,10:12
iex(1)> Geometry.area({:circle, 83})

defmodule Geometry do
  def area({:rectangle, a, b}) do
    a * b
  end
  def area({:square, a}) do
    a * a
  end
  def area({:circle, r}) do
    r * r * 3.14
  end
end
```

<div style="padding: 20px">
<p>the BEAM (virtual machine) will try to match each clause from top to bottom, and calls the first that matches. In this case the third one.</p>
</div>

</Step>

</CodeSurferColumns>

---

# 8

## Guards

<div style="padding: 20px">
<p>Almost like multiclause functions, but slightly different</p>
</div>

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
defmodule TestNum do
  def test(x) when x < 0 do
    :negative
  end
  def test(0), do: :zero
  def test(x) when x > 0 do
    :positive
  end
end
```


<div style="padding: 20px">
<p>if the value of the argument to `test/1` is negative, call the first, 0, call the second, positive, call the third.</p>
</div>

</Step>

</CodeSurferColumns>

---

## arity, multiclause, guards, pattern matching

<div style="padding: 20px">
<p>they eliminate a LOT of work that we need to deal with data checking inside our functions, like JavaScript or PHP.</p><p>Pattern matching replaces a whole bunch of regex applications.</p>
</div>

---

# 9

## loops, iterations

<div style="padding: 20px">
<p>Everything is a recursive call, except for `comprehensions`</p>
<p>Tail recursion incurs no memory overhead, so can go arbitrarily long</p>
</div>

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
defmodule ListHelper do
  def sum([]), do: 0
  def sum([head | tail]) do
    head + sum(tail)
  end
end
```

<div style="padding: 20px">
<p>Calculates the sum of a list. No for loop, no intermediate variable, just multiclause functions and pattern matching / deconstruction.</p>
<p>This is not tail recursive though, because the last thing that happens is an addition</p>
</div>

</Step>

</CodeSurferColumns>

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
defmodule ListHelper do
  def sum(list) do
    do_sum(0, list)
  end
  defp do_sum(current_sum, []) do
    current_sum
  end
  defp do_sum(current_sum, [head | tail]) do
    new_sum = head + current_sum
    do_sum(new_sum, tail)
  end
end
```

<div style="padding: 20px">
<p>This is the same functionality with tail recursion, a public, and two private functions with pattern matching and deconstruction.</p>
</div>

</Step>

<Step>

```elixir 2
defmodule ListHelper do
  def sum(list) do
    do_sum(0, list)
  end
  defp do_sum(current_sum, []) do
    current_sum
  end
  defp do_sum(current_sum, [head | tail]) do
    new_sum = head + current_sum
    do_sum(new_sum, tail)
  end
end
```

<div style="padding: 20px">
<p>you call this</p>
</div>

</Step>

<Step>

```elixir 8:11
defmodule ListHelper do
  def sum(list) do
    do_sum(0, list)
  end
  defp do_sum(current_sum, []) do
    current_sum
  end
  defp do_sum(current_sum, [head | tail]) do
    new_sum = head + current_sum
    do_sum(new_sum, tail)
  end
end
```

<div style="padding: 20px">
<p>incoming to do_sum you have whatever you had previously, and the list's head, and the rest of the list.</p>
<p>then you do math, and keep doing it until the tail is an empty list</p>
</div>

</Step>

<Step>

```elixir 5:7
defmodule ListHelper do
  def sum(list) do
    do_sum(0, list)
  end
  defp do_sum(current_sum, []) do
    current_sum
  end
  defp do_sum(current_sum, [head | tail]) do
    new_sum = head + current_sum
    do_sum(new_sum, tail)
  end
end
```

<div style="padding: 20px">
<p>and when it is an empty list, you return whatever you had until that point</p>
</div>

</Step>

<Step>

```elixir 10
defmodule ListHelper do
  def sum(list) do
    do_sum(0, list)
  end
  defp do_sum(current_sum, []) do
    current_sum
  end
  defp do_sum(current_sum, [head | tail]) do
    new_sum = head + current_sum
    do_sum(new_sum, tail)
  end
end
```

<div style="padding: 20px">
<p>and it's tail recursive because the very last thing that happens inside the func is calling another func</p>
</div>

</Step>

</CodeSurferColumns>

---

# 10

## comprehensions

<div style="padding: 20px"><p>
Essentially code that elixir can figure out what to do with.
</p></div>

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
# elixir
iex(2)> for x <- [1, 2, 3], y <- [1, 2, 3], do: {x, y, x*y}
[
  {1, 1, 1}, {1, 2, 2}, {1, 3, 3},
  {2, 1, 2}, {2, 2, 4}, {2, 3, 6},
  {3, 1, 3}, {3, 2, 6}, {3, 3, 9}
]
```

```go
# go
table := make([][]int, 0)
for i := 1; i < 4; i++ {
  for j := 1; j < 4; j++ {
    table = append(table, []int{i, j, i*j})
  }
}
```

</Step>

</CodeSurferColumns>

---

# 11

## End for today

<div style="padding: 20px">
<p>This was a not at all exhaustive list of cool stuff elixir does. I will try to answer some questions!</p>
</div>