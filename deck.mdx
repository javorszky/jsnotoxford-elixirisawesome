import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { oceanicNext } from "@code-surfer/themes";
import {
  themes,
} from "mdx-deck"
import "prismjs/components/prism-elixir"

import elixirlogo from "./static/elixirlogo.png"
export const theme = themes.yellow;


# Elixir is amazing! üòç

---

# Who?

## Gabor Javorszky
backend developer (Go mainly)

Hello üëã

---

# But what is

<img src={elixirlogo} />

---
<blockquote>
  <p>‚ÄùElixir is a dynamic, functional language designed for building scalable and maintainable applications.</p>
  <p>Elixir leverages the Erlang VM, known for running low-latency, distributed and fault-tolerant systems, while also being successfully used in web development, embedded software, data ingestion, and multimedia processing domains across a wide range of industries.‚Äù</p>
  <footer>
    <cite>‚Äî <a href="https://elixir-lang.org/">elixir site</a></cite>
  </footer>
</blockquote>

---

### dynamic:

no type hint / type coercion when writing code

### functional:

everything is done with functions with no side effects. Also data is immutable!

---

# note before we go further

I'm on page 100 of the 350 page book.

I don't know a LOT of things.

But these have blown my mind so far!

---

# 1

<div style="padding: 20px"><p>
pretty much most things are an expression. An expression is a thing that has a return value.</p></div>


<CodeSurferColumns themes={[oceanicNext,themes.yellow]}  sizes={[3,2]}>

<Step>

```elixir
iex(1) > 2 * (
          3+ 1
        )/ 4
2.0
```

Everything together

</Step>

<Step>

```elixir 1[1:8]
iex(1) > 2 * (
          3+ 1
        )/ 4
2.0
```

The shell

</Step>

<Step>

```elixir 1[10:14],2,3
iex(1) > 2 * (
          3+ 1
        )/ 4
2.0
```

<div style="padding: 20px">
<p>An expression</p><p>If you hit enter in the shell while the expression is not finished, it will give you a new line to keep writing. Once the expression can be finished, it evaluates.</p>
</div>


</Step>

<Step>

```elixir 4
iex(1) > 2 * (
          3+ 1
        )/ 4
2.0
```

the return value

</Step>

</CodeSurferColumns>

---

# 2

<div style="padding: 20px"><p>
Code is organised into modules and functions within those modules</p></div>

<CodeSurferColumns themes={[oceanicNext,themes.yellow]}  sizes={[3,2]}>

<Step>

```elixir
defmodule MyModule
  def add(x, y) do
    x+y
  end
end
```

<div style="padding: 20px">
<p>A module with a function</p>
</div>

</Step>

<Step>

```elixir 1,5
defmodule MyModule
  def add(x, y) do
    x+y
  end
end
```

<div style="padding: 20px">
<p>Module definition goes between `defmodule SomeName do ... end` blocks</p>
</div>

</Step>

<Step>

```elixir 2:4
defmodule MyModule
  def add(x, y) do
    x+y
  end
end
```

<div style="padding: 20px">
<p>Function definition goes between `def SomeName do ... end` blocks</p>
</div>

</Step>

</CodeSurferColumns>

---

# 3

<div style="padding: 20px">
<p>Functions with the same name, but different <i>arity</i> are different functions.</p>

<p>Arity: how many arguments go into a function.</p>
</div>

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir 1:17
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    0.25 * 1.7320508075688772 * x * x
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    0.5 * base * base * :math.sqrt(((sides*sides)/(base*base)) - 0.25)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>Triangle module with three different functions all called `area` to calculate the areas differently for each of them.</p>
</div>

</Step>

<Step>

```elixir 2:5
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    0.25 * 1.7320508075688772 * x * x
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    0.5 * base * base * :math.sqrt(((sides*sides)/(base*base)) - 0.25)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>This is denoted as `Triangle.area/1`</p><p>The `/n` shows how many arguments go into a function</p>
</div>

</Step>

<Step>

```elixir 7:10
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    0.25 * 1.7320508075688772 * x * x
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    0.5 * base * base * :math.sqrt(((sides*sides)/(base*base)) - 0.25)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>Triangle.area/2</p>
</div>

</Step>

<Step>

```elixir 11:16
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    0.25 * 1.7320508075688772 * x * x
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    0.5 * base * base * :math.sqrt(((sides*sides)/(base*base)) - 0.25)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>Triangle.area/3</p>
</div>

</Step>

</CodeSurferColumns>

---

# 4

## Private functions!

Functions that can only be called by the same module.

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir 1:17
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    0.25 * 1.7320508075688772 * x * x
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    0.5 * base * base * :math.sqrt(((sides*sides)/(base*base)) - 0.25)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>This can be done more generically</p>
</div>

</Step>

<Step>

```elixir 4,9,14,17:20
defmodule Triangle do
  def area(x) do
    IO.puts("calculating equilateral triangle")
    generic_area(x, x, x)
  end

  def area(base, sides) do
    IO.puts("calculating isosceles triangle")
    generic_area(base, sides, sides)
  end

  def area(x, y, z) do
    IO.puts("calculating scalene triangle")
    generic_area(x, y, z)
  end

  defp generic_area(x, y, z) do
    s = 0.5 * (x + y + z)
    :math.sqrt(s * (s-x) * (s-y) * (s-z))
  end
end
```

<div style="padding: 20px">
<p>`defp` is a private function. Only functions inside the same module can call it. You can't call Triangle.generic_area.</p>
</div>

</Step>

<Step>

```elixir
iex(2)> Triangle.area(3)
calculating equilateral triangle
3.897114317029974
iex(3)> Triangle.area(3,3)
calculating isosceles triangle
3.897114317029974
iex(4)> Triangle.area(3,3,3)
calculating scalene triangle
3.897114317029974
iex(5)> Triangle.generic_area(3,3,3)
** (UndefinedFunctionError) function Triangle.generic_area/3 is undefined or private
    Triangle.generic_area(3, 3, 3)
```

<div style="padding: 20px">
<p>Output confirms that it works :)</p><p>And that you also can't call the private function</p>
</div>

</Step>

</CodeSurferColumns>

---

# 5

## A list is a singly linked list

An thus has an O(n) complexity to traverse or do pretty much anything with them.

---

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
[1, 2, 3, 4]

is the same as

[1 | [2, 3, 4]]

and

[1 | [2 | [3, 4]]]

and

[1 | [2 | [3 | [4]]]
```

```elixir
[head | tail]

where tail is the "rest of the list", or the rest of the ü¶â
```

</Step>

<Step>

```elixir 5[2]
[1, 2, 3, 4]

is the same as

[1 | [2, 3, 4]]

and

[1 | [2 | [3, 4]]]

and

[1 | [2 | [3 | [4]]]
```

```elixir
[head | tail]

where tail is the "rest of the list", or the rest of the ü¶â
```

</Step>

<Step>

```elixir 5[6:14]
[1, 2, 3, 4]

is the same as

[1 | [2, 3, 4]]

and

[1 | [2 | [3, 4]]]

and

[1 | [2 | [3 | [4]]]
```

```elixir
[head | tail]

where tail is the "rest of the list", or the rest of the ü¶â
```

</Step>

</CodeSurferColumns>

---

# 6

## the = is actually pattern matching

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
iex(1) > person = {"Bob", 25}
```

<div style="padding: 20px">
<p>the thing on the right is matched into the thing on the left. `person` is going to be bound to that tuple</p>
</div>

</Step>

<Step>

```elixir
iex(1)> {name, age} = {"Bob", 25}
{"Bob", 25}
iex(2)> name
"Bob"
iex(3)> age
25
```

<div style="padding: 20px">
<p>super useful to extract things from other things</p>
</div>

</Step>

<Step>

```elixir 1[10:13,24:28]
iex(1)> {name, age} = {"Bob", 25}
{"Bob", 25}
iex(2)> name
"Bob"
iex(3)> age
25
```

<div style="padding: 20px">
<p>super useful to extract things from other things</p>
</div>

</Step>

<Step>

```elixir 1[15:18,31:32]
iex(1)> {name, age} = {"Bob", 25}
{"Bob", 25}
iex(2)> name
"Bob"
iex(3)> age
25
```

<div style="padding: 20px">
<p>super useful to extract things from other things</p>
</div>

</Step>

</CodeSurferColumns>

---

Which also means we can do super cool extraction stuff like getting only the hour of the local time!

<CodeSurferColumns themes={[oceanicNext,themes.yellow]} sizes={[3,2]}>

<Step>

```elixir
iex(5)> :calendar.local_time()
{{2021, 1, 13}, {17, 4, 16}}
```

<div style="padding: 20px">
<p>nonmatched but evaluated local time looks like this</p>
</div>

</Step>

<Step>

```elixir
iex(6)> {_, time} = :calendar.local_time()
{{2021, 1, 13}, {17, 4, 16}}
iex(7)> time
{17, 4, 16}
```

<div style="padding: 20px">
<p>separate them to date and time. The underscore means we don't care about that. Match it, but don't bind it.</p>
</div>

</Step>

<Step>

```elixir
iex(8)> {_, {hour, _, _}} = :calendar.local_time()
{{2021, 1, 13}, {17, 4, 16}}
iex(9)> hour
17
```

<div style="padding: 20px">
<p>and voila, we can go arbitrarily deep in the structure of the result.</p>
</div>

</Step>

</CodeSurferColumns>

---


<CodeSurfer theme={oceanicNext}>

```js 1:2,3[8:10]
console.log(1);
console.log(2);
console.log(3);
```

```js 1:2,3[8:10]
console.log(1);

function bla() {
  echo some content;
}

console.log(2);
console.log(3);
```

```js title="This is a title" subtitle="and this a subtitle"
function lorem(ipsum, dolor = 1) {
  const sit = ipsum == null ? 0 : ipsum.sit;
  dolor = sit - amet(dolor);
  return sit
    ? consectetur(ipsum, 0, dolor < 0 ? 0 : dolor)
    : [];
}

function incididunt(ipsum, ut = 1) {
  ut = labore.et(amet(ut), 0);
  const sit = ipsum == null ? 0 : ipsum.sit;

  if (!sit || ut < 1) {
    return [];
  }

  let dolore = 0;
  let magna = 0;
  const aliqua = new eiusmod(labore.ut(sit / ut));

  while (dolore < sit) {
    aliqua[magna++] = consectetur(
      ipsum,
      dolore,
      (dolore += ut)
    );
  }

  return aliqua;
}
```

```js
function lorem(ipsum, dolor = 1) {
  const sit = ipsum == null ? 0 : ipsum.sit;
  dolor = sit - amet(dolor);
  return sit
    ? consectetur(ipsum, 0, dolor < 0 ? 0 : dolor)
    : [];
}

function adipiscing(...elit) {
  if (!elit.sit) {
    return [];
  }

  const sed = elit[0];
  return eiusmod.tempor(sed) ? sed : [sed];
}

function incididunt(ipsum, ut = 1) {
  ut = labore.et(amet(ut), 0);
  const sit = ipsum == null ? 0 : ipsum.sit;

  if (!sit || ut < 1) {
    return [];
  }

  let dolore = 0;
  let magna = 0;
  const aliqua = new eiusmod(labore.ut(sit / ut));

  while (dolore < sit) {
    aliqua[magna++] = consectetur(
      ipsum,
      dolore,
      (dolore += ut)
    );
  }

  return aliqua;
}
```

```diff 1[10:14],2[15:19],3[22:27],10:12

```

</CodeSurfer>

---

<CodeSurferColumns>

<Step>

```js
const magna = aliqua => aliqua.ut((enim, ad) => enim, 0);
```

```js
const minim = (ad, enim) => dolore.magna(ad / enim);
```

</Step>

<Step>

```js
const lorem = (ipsum, dolor, sit) => {
  const amet = dolor - ipsum;
  return consectetur.adipiscing(
    {
      elit: sed.eiusmod(sit - dolor) / amet + 2,
    },
    (tempor, incididunt) => ipsum + amet * incididunt
  );
};

const magna = aliqua => aliqua.ut((enim, ad) => enim, 0);
```

```js
const minim = (ad, enim) => dolore.magna(ad / enim);

const sed = (eiusmod, tempor, incididunt) => {
  const ut = tempor - eiusmod;
  return labore.et(
    {
      amet: dolore.magna(incididunt - tempor) / ut + 2,
    },
    (aliqua, elit) => eiusmod + ut * elit
  );
};
```

</Step>

</CodeSurferColumns>

---

docs:
[codesurfer.pomb.us](https://codesurfer.pomb.us)
